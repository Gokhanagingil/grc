import { MigrationInterface, QueryRunner } from 'typeorm';

/**
 * Baseline Migration - GRC Platform Schema
 * 
 * This migration represents the current state of the GRC platform schema
 * as of Sprint 2. It is designed to work with both SQLite and PostgreSQL.
 * 
 * For PostgreSQL:
 * - Uses schema prefixes (auth, tenant, app, audit, comms)
 * - Uses Postgres-specific features (extensions, JSONB, etc.)
 * 
 * For SQLite:
 * - Schema prefixes are ignored (all tables in default schema)
 * - Uses SQLite-compatible data types
 * - JSONB becomes TEXT with JSON content
 * 
 * Usage:
 * - This migration should be used to create a fresh database from scratch
 * - It does NOT modify existing databases (that's handled separately)
 * - Run with: npm run migration:run
 */
export class BaselineGrcSchema20250126000000 implements MigrationInterface {
  name = 'BaselineGrcSchema20250126000000';

  public async up(queryRunner: QueryRunner): Promise<void> {
    const isPostgres = queryRunner.connection.options.type === 'postgres';
    
    // Helper function to get table name with optional schema prefix
    const tableName = (schema: string, table: string): string => {
      if (isPostgres) {
        return `${schema}.${table}`;
      }
      return table; // SQLite doesn't support schemas
    };

    // Helper function to get UUID default
    // Note: SQLite doesn't support UUID generation in DEFAULT clause
    // UUIDs should be generated by the application layer for SQLite
    const uuidDefault = (): string => {
      if (isPostgres) {
        return 'gen_random_uuid()';
      }
      // SQLite: No default, application must provide UUID
      return '';
    };

    // Helper function to get timestamp default
    const timestampDefault = (): string => {
      if (isPostgres) {
        return 'now()';
      }
      return "CURRENT_TIMESTAMP";
    };

    // Helper function to get JSON column type
    const jsonType = (): string => {
      if (isPostgres) {
        return 'JSONB';
      }
      return 'TEXT'; // SQLite stores JSON as TEXT
    };

    // Helper function to get text type (CITEXT for Postgres, TEXT for SQLite)
    const textType = (): string => {
      if (isPostgres) {
        return 'CITEXT';
      }
      return 'TEXT';
    };

    // PostgreSQL: Create extensions and schemas
    if (isPostgres) {
      await queryRunner.query(`CREATE EXTENSION IF NOT EXISTS pgcrypto;`);
      await queryRunner.query(`CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`);
      await queryRunner.query(`CREATE EXTENSION IF NOT EXISTS citext;`);
      await queryRunner.query(`CREATE EXTENSION IF NOT EXISTS ltree;`);

      await queryRunner.query(`CREATE SCHEMA IF NOT EXISTS auth;`);
      await queryRunner.query(`CREATE SCHEMA IF NOT EXISTS tenant;`);
      await queryRunner.query(`CREATE SCHEMA IF NOT EXISTS app;`);
      await queryRunner.query(`CREATE SCHEMA IF NOT EXISTS audit;`);
      await queryRunner.query(`CREATE SCHEMA IF NOT EXISTS comms;`);
    }

    // ============================================================================
    // TENANT SCHEMA
    // ============================================================================

    const tenantsTable = `
      CREATE TABLE IF NOT EXISTS ${tableName('tenant', 'tenants')} (
        id ${isPostgres ? 'UUID' : 'TEXT'} PRIMARY KEY ${isPostgres ? `DEFAULT ${uuidDefault()}` : 'NOT NULL'},
        name TEXT NOT NULL${isPostgres ? ' UNIQUE' : ''},
        slug TEXT NOT NULL${isPostgres ? ' UNIQUE' : ''},
        is_active ${isPostgres ? 'BOOLEAN' : 'INTEGER'} NOT NULL DEFAULT ${isPostgres ? 'true' : '1'},
        created_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()},
        updated_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()}
      );
    `;
    await queryRunner.query(tenantsTable);

    if (!isPostgres) {
      // SQLite unique constraints
      await queryRunner.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_tenants_name ON ${tableName('tenant', 'tenants')}(name);
      `);
      await queryRunner.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_tenants_slug ON ${tableName('tenant', 'tenants')}(slug);
      `);
    }

    // ============================================================================
    // AUTH SCHEMA
    // ============================================================================

    const usersTable = `
      CREATE TABLE IF NOT EXISTS ${tableName('auth', 'users')} (
        id ${isPostgres ? 'UUID' : 'TEXT'} PRIMARY KEY ${isPostgres ? `DEFAULT ${uuidDefault()}` : 'NOT NULL'},
        tenant_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        email ${textType()} NOT NULL,
        password_hash TEXT NOT NULL,
        display_name TEXT,
        is_email_verified ${isPostgres ? 'BOOLEAN' : 'INTEGER'} NOT NULL DEFAULT ${isPostgres ? 'false' : '0'},
        is_active ${isPostgres ? 'BOOLEAN' : 'INTEGER'} NOT NULL DEFAULT ${isPostgres ? 'true' : '1'},
        mfa_enabled ${isPostgres ? 'BOOLEAN' : 'INTEGER'} NOT NULL DEFAULT ${isPostgres ? 'false' : '0'},
        mfa_secret TEXT,
        failed_attempts INTEGER NOT NULL DEFAULT 0,
        locked_until ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'},
        twofa_secret TEXT,
        roles ${jsonType()} ${isPostgres ? "DEFAULT '[]'" : "DEFAULT '[]'"},
        created_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()},
        updated_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()}${isPostgres ? ',\n        UNIQUE (tenant_id, email)' : ''}
      );
    `;
    await queryRunner.query(usersTable);

    if (!isPostgres) {
      await queryRunner.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_users_tenant_email ON ${tableName('auth', 'users')}(tenant_id, email);
      `);
    }

    await queryRunner.query(`
      CREATE INDEX IF NOT EXISTS idx_users_tenant_entity ON ${tableName('auth', 'users')}(tenant_id);
    `);
    await queryRunner.query(`
      CREATE INDEX IF NOT EXISTS idx_users_locked_until ON ${tableName('auth', 'users')}(locked_until);
    `);

    // Foreign key: users.tenant_id -> tenants.id
    if (isPostgres) {
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'users')} 
        DROP CONSTRAINT IF EXISTS fk_users_tenant CASCADE;
      `);
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'users')} 
        ADD CONSTRAINT fk_users_tenant 
        FOREIGN KEY(tenant_id) REFERENCES ${tableName('tenant', 'tenants')}(id) ON DELETE CASCADE;
      `);
    }

    const rolesTable = `
      CREATE TABLE IF NOT EXISTS ${tableName('auth', 'roles')} (
        id ${isPostgres ? 'UUID' : 'TEXT'} PRIMARY KEY ${isPostgres ? `DEFAULT ${uuidDefault()}` : 'NOT NULL'},
        tenant_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        name TEXT NOT NULL,
        description TEXT,
        is_system ${isPostgres ? 'BOOLEAN' : 'INTEGER'} NOT NULL DEFAULT ${isPostgres ? 'false' : '0'},
        created_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()},
        updated_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()}${isPostgres ? ',\n        UNIQUE (tenant_id, name)' : ''}
      );
    `;
    await queryRunner.query(rolesTable);

    if (!isPostgres) {
      await queryRunner.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_roles_tenant_name ON ${tableName('auth', 'roles')}(tenant_id, name);
      `);
    }

    await queryRunner.query(`
      CREATE INDEX IF NOT EXISTS idx_roles_tenant_entity ON ${tableName('auth', 'roles')}(tenant_id);
    `);

    // Foreign key: roles.tenant_id -> tenants.id
    if (isPostgres) {
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'roles')} 
        DROP CONSTRAINT IF EXISTS fk_roles_tenant CASCADE;
      `);
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'roles')} 
        ADD CONSTRAINT fk_roles_tenant 
        FOREIGN KEY(tenant_id) REFERENCES ${tableName('tenant', 'tenants')}(id) ON DELETE CASCADE;
      `);
    }

    await queryRunner.query(`
      CREATE TABLE IF NOT EXISTS ${tableName('auth', 'permissions')} (
        id ${isPostgres ? 'UUID' : 'TEXT'} PRIMARY KEY ${isPostgres ? `DEFAULT ${uuidDefault()}` : 'NOT NULL'},
        code TEXT NOT NULL ${isPostgres ? 'UNIQUE' : ''},
        description TEXT,
        created_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()},
        updated_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()}
      );
    `);

    if (!isPostgres) {
      await queryRunner.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_permissions_code ON ${tableName('auth', 'permissions')}(code);
      `);
    }

    await queryRunner.query(`
      CREATE TABLE IF NOT EXISTS ${tableName('auth', 'role_permissions')} (
        role_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        permission_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        PRIMARY KEY (role_id, permission_id)
      );
    `);

    await queryRunner.query(`
      CREATE TABLE IF NOT EXISTS ${tableName('auth', 'user_roles')} (
        user_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        role_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        PRIMARY KEY (user_id, role_id)
      );
    `);

    await queryRunner.query(`
      CREATE TABLE IF NOT EXISTS ${tableName('auth', 'refresh_tokens')} (
        id ${isPostgres ? 'UUID' : 'TEXT'} PRIMARY KEY ${isPostgres ? `DEFAULT ${uuidDefault()}` : 'NOT NULL'},
        user_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        token_hash TEXT NOT NULL,
        expires_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL,
        created_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()},
        revoked_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'}
      );
    `);

    // Foreign keys for auth tables
    if (isPostgres) {
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'role_permissions')} 
        DROP CONSTRAINT IF EXISTS fk_role_permissions_role CASCADE;
      `);
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'role_permissions')} 
        ADD CONSTRAINT fk_role_permissions_role 
        FOREIGN KEY(role_id) REFERENCES ${tableName('auth', 'roles')}(id) ON DELETE CASCADE;
      `);

      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'role_permissions')} 
        DROP CONSTRAINT IF EXISTS fk_role_permissions_permission CASCADE;
      `);
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'role_permissions')} 
        ADD CONSTRAINT fk_role_permissions_permission 
        FOREIGN KEY(permission_id) REFERENCES ${tableName('auth', 'permissions')}(id) ON DELETE CASCADE;
      `);

      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'user_roles')} 
        DROP CONSTRAINT IF EXISTS fk_user_roles_user CASCADE;
      `);
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'user_roles')} 
        ADD CONSTRAINT fk_user_roles_user 
        FOREIGN KEY(user_id) REFERENCES ${tableName('auth', 'users')}(id) ON DELETE CASCADE;
      `);

      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'user_roles')} 
        DROP CONSTRAINT IF EXISTS fk_user_roles_role CASCADE;
      `);
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'user_roles')} 
        ADD CONSTRAINT fk_user_roles_role 
        FOREIGN KEY(role_id) REFERENCES ${tableName('auth', 'roles')}(id) ON DELETE CASCADE;
      `);

      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'refresh_tokens')} 
        DROP CONSTRAINT IF EXISTS fk_refresh_tokens_user CASCADE;
      `);
      await queryRunner.query(`
        ALTER TABLE ${tableName('auth', 'refresh_tokens')} 
        ADD CONSTRAINT fk_refresh_tokens_user 
        FOREIGN KEY(user_id) REFERENCES ${tableName('auth', 'users')}(id) ON DELETE CASCADE;
      `);
    }

    // ============================================================================
    // APP SCHEMA - Core Tables
    // ============================================================================

    // Policies
    const policiesTable = `
      CREATE TABLE IF NOT EXISTS ${tableName('app', 'policies')} (
        id ${isPostgres ? 'UUID' : 'TEXT'} PRIMARY KEY ${isPostgres ? `DEFAULT ${uuidDefault()}` : 'NOT NULL'},
        tenant_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        code TEXT NOT NULL,
        title TEXT NOT NULL,
        status TEXT NOT NULL,
        owner_first_name TEXT,
        owner_last_name TEXT,
        effective_date ${isPostgres ? 'DATE' : 'TEXT'},
        review_date ${isPostgres ? 'DATE' : 'TEXT'},
        content TEXT,
        created_by ${isPostgres ? 'UUID' : 'TEXT'},
        updated_by ${isPostgres ? 'UUID' : 'TEXT'},
        created_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()},
        updated_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()}${isPostgres ? ',\n        UNIQUE (tenant_id, code)' : ''}
      );
    `;
    await queryRunner.query(policiesTable);

    if (!isPostgres) {
      await queryRunner.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_policies_tenant_code ON ${tableName('app', 'policies')}(tenant_id, code);
      `);
    }

    await queryRunner.query(`
      CREATE INDEX IF NOT EXISTS idx_policies_tenant ON ${tableName('app', 'policies')}(tenant_id);
    `);

    // Foreign key: policies.tenant_id -> tenants.id
    if (isPostgres) {
      await queryRunner.query(`
        ALTER TABLE ${tableName('app', 'policies')} 
        DROP CONSTRAINT IF EXISTS fk_policies_tenant CASCADE;
      `);
      await queryRunner.query(`
        ALTER TABLE ${tableName('app', 'policies')} 
        ADD CONSTRAINT fk_policies_tenant 
        FOREIGN KEY(tenant_id) REFERENCES ${tableName('tenant', 'tenants')}(id) ON DELETE CASCADE;
      `);
    }

    // Standards
    const standardTable = `
      CREATE TABLE IF NOT EXISTS ${tableName('app', 'standard')} (
        id ${isPostgres ? 'UUID' : 'TEXT'} PRIMARY KEY ${isPostgres ? `DEFAULT ${uuidDefault()}` : 'NOT NULL'},
        tenant_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        code VARCHAR(50) NOT NULL,
        name TEXT NOT NULL,
        version VARCHAR(20),
        publisher VARCHAR(100),
        created_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()},
        updated_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()}${isPostgres ? ',\n        UNIQUE (tenant_id, code)' : ''}
      );
    `;
    await queryRunner.query(standardTable);

    if (!isPostgres) {
      await queryRunner.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_standard_tenant_code ON ${tableName('app', 'standard')}(tenant_id, code);
      `);
    }

    await queryRunner.query(`
      CREATE INDEX IF NOT EXISTS idx_standard_tenant ON ${tableName('app', 'standard')}(tenant_id);
    `);

    // Risk Category
    const riskCategoryTable = `
      CREATE TABLE IF NOT EXISTS ${tableName('app', 'risk_category')} (
        id ${isPostgres ? 'UUID' : 'TEXT'} PRIMARY KEY ${isPostgres ? `DEFAULT ${uuidDefault()}` : 'NOT NULL'},
        tenant_id ${isPostgres ? 'UUID' : 'TEXT'} NOT NULL,
        code VARCHAR(50) NOT NULL,
        name TEXT NOT NULL,
        description TEXT,
        created_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()},
        updated_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()}${isPostgres ? ',\n        UNIQUE (tenant_id, code)' : ''}
      );
    `;
    await queryRunner.query(riskCategoryTable);

    if (!isPostgres) {
      await queryRunner.query(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_risk_category_tenant_code ON ${tableName('app', 'risk_category')}(tenant_id, code);
      `);
    }

    await queryRunner.query(`
      CREATE INDEX IF NOT EXISTS idx_risk_category_tenant ON ${tableName('app', 'risk_category')}(tenant_id);
    `);

    // ============================================================================
    // AUDIT SCHEMA
    // ============================================================================

    await queryRunner.query(`
      CREATE TABLE IF NOT EXISTS ${tableName('audit', 'audit_logs')} (
        id ${isPostgres ? 'BIGSERIAL' : 'INTEGER'} PRIMARY KEY ${isPostgres ? '' : 'AUTOINCREMENT'},
        tenant_id ${isPostgres ? 'UUID' : 'TEXT'},
        user_id ${isPostgres ? 'UUID' : 'TEXT'},
        entity_schema TEXT NOT NULL,
        entity_table TEXT NOT NULL,
        entity_id ${isPostgres ? 'UUID' : 'TEXT'},
        action TEXT NOT NULL,
        diff ${jsonType()},
        created_at ${isPostgres ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT ${timestampDefault()}
      );
    `);

    // Note: Additional tables (standard_clause, control_library, risk_catalog, etc.)
    // are created by subsequent migrations. This baseline migration focuses on
    // the core foundation tables that are essential for the system to function.
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const isPostgres = queryRunner.connection.options.type === 'postgres';
    
    const tableName = (schema: string, table: string): string => {
      if (isPostgres) {
        return `${schema}.${table}`;
      }
      return table;
    };

    // Drop tables in reverse order
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('audit', 'audit_logs')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('app', 'risk_category')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('app', 'standard')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('app', 'policies')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('auth', 'refresh_tokens')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('auth', 'user_roles')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('auth', 'role_permissions')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('auth', 'permissions')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('auth', 'roles')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('auth', 'users')}`);
    await queryRunner.query(`DROP TABLE IF EXISTS ${tableName('tenant', 'tenants')}`);

    // Drop schemas (PostgreSQL only)
    if (isPostgres) {
      await queryRunner.query(`DROP SCHEMA IF EXISTS comms CASCADE`);
      await queryRunner.query(`DROP SCHEMA IF EXISTS audit CASCADE`);
      await queryRunner.query(`DROP SCHEMA IF EXISTS app CASCADE`);
      await queryRunner.query(`DROP SCHEMA IF EXISTS auth CASCADE`);
      await queryRunner.query(`DROP SCHEMA IF EXISTS tenant CASCADE`);
    }
  }
}

