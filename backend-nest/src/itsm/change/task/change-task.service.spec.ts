import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import {
  BadRequestException,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { ChangeTaskService } from './change-task.service';
import { ItsmChangeTask, ChangeTaskStatus, ChangeTaskType, ChangeTaskPriority } from './change-task.entity';
import { ItsmChangeTaskDependency } from './change-task-dependency.entity';
import { ItsmChange } from '../change.entity';

describe('ChangeTaskService', () => {
  let service: ChangeTaskService;
  let taskRepo: jest.Mocked<Repository<ItsmChangeTask>>;
  let depRepo: jest.Mocked<Repository<ItsmChangeTaskDependency>>;
  let changeRepo: jest.Mocked<Repository<ItsmChange>>;

  const TENANT = '00000000-0000-0000-0000-000000000001';
  const USER = '00000000-0000-0000-0000-000000000002';
  const CHANGE_ID = '00000000-0000-0000-0000-000000000010';
  const TASK_A = '00000000-0000-0000-0000-0000000000a1';
  const TASK_B = '00000000-0000-0000-0000-0000000000a2';
  const TASK_C = '00000000-0000-0000-0000-0000000000a3';
  const OTHER_CHANGE = '00000000-0000-0000-0000-000000000099';
  const OTHER_TENANT = '00000000-0000-0000-0000-000000000099';

  const makeTask = (overrides: Partial<ItsmChangeTask> = {}): ItsmChangeTask =>
    ({
      id: TASK_A,
      tenantId: TENANT,
      changeId: CHANGE_ID,
      number: 'CTASK00001',
      title: 'Test Task',
      description: null,
      status: ChangeTaskStatus.OPEN,
      taskType: ChangeTaskType.OTHER,
      assignmentGroupId: null,
      assigneeId: null,
      priority: ChangeTaskPriority.MEDIUM,
      plannedStartAt: null,
      plannedEndAt: null,
      actualStartAt: null,
      actualEndAt: null,
      sequenceOrder: 0,
      isBlocking: true,
      autoGenerated: false,
      sourceTemplateId: null,
      templateTaskKey: null,
      sortOrder: 0,
      stageLabel: null,
      notes: null,
      estimatedDurationMinutes: null,
      isDeleted: false,
      createdBy: USER,
      updatedBy: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides,
    }) as ItsmChangeTask;

  const makeDep = (pred: string, succ: string): ItsmChangeTaskDependency =>
    ({
      id: `dep-${pred}-${succ}`,
      tenantId: TENANT,
      changeId: CHANGE_ID,
      predecessorTaskId: pred,
      successorTaskId: succ,
      createdAt: new Date(),
    }) as ItsmChangeTaskDependency;

  beforeEach(async () => {
    const mockTaskRepo = {
      find: jest.fn(),
      findOne: jest.fn(),
      save: jest.fn(),
      create: jest.fn(),
      count: jest.fn(),
      createQueryBuilder: jest.fn(),
      merge: jest.fn().mockImplementation((entity, data) => ({ ...entity, ...data })),
    };

    const mockDepRepo = {
      find: jest.fn(),
      findOne: jest.fn(),
      save: jest.fn(),
      create: jest.fn(),
      remove: jest.fn(),
      createQueryBuilder: jest.fn(),
    };

    const mockChangeRepo = {
      findOne: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ChangeTaskService,
        { provide: getRepositoryToken(ItsmChangeTask), useValue: mockTaskRepo },
        { provide: getRepositoryToken(ItsmChangeTaskDependency), useValue: mockDepRepo },
        { provide: getRepositoryToken(ItsmChange), useValue: mockChangeRepo },
      ],
    }).compile();

    service = module.get<ChangeTaskService>(ChangeTaskService);
    taskRepo = module.get(getRepositoryToken(ItsmChangeTask));
    depRepo = module.get(getRepositoryToken(ItsmChangeTaskDependency));
    changeRepo = module.get(getRepositoryToken(ItsmChange));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  // ──────────────────────────────────────────────────────────────────
  // CREATE TASK
  // ──────────────────────────────────────────────────────────────────
  describe('createTask', () => {
    it('should create a task with auto-generated number', async () => {
      changeRepo.findOne.mockResolvedValue({ id: CHANGE_ID } as ItsmChange);
      taskRepo.count.mockResolvedValue(0);
      taskRepo.create.mockImplementation((data) => data as ItsmChangeTask);
      taskRepo.save.mockImplementation(async (entity) => ({
        ...entity,
        id: TASK_A,
      }) as ItsmChangeTask);

      const result = await service.createTask(TENANT, USER, CHANGE_ID, {
        title: 'New Task',
        status: ChangeTaskStatus.OPEN,
      });

      expect(result).toBeDefined();
      expect(taskRepo.create).toHaveBeenCalledWith(
        expect.objectContaining({
          tenantId: TENANT,
          changeId: CHANGE_ID,
          number: 'CTASK00001',
          title: 'New Task',
          createdBy: USER,
          isDeleted: false,
        }),
      );
    });

    it('should throw NotFoundException when change does not exist', async () => {
      changeRepo.findOne.mockResolvedValue(null);

      await expect(
        service.createTask(TENANT, USER, 'non-existent', { title: 'X' }),
      ).rejects.toThrow(NotFoundException);
    });

    it('should increment task number based on existing count', async () => {
      changeRepo.findOne.mockResolvedValue({ id: CHANGE_ID } as ItsmChange);
      taskRepo.count.mockResolvedValue(5);
      taskRepo.create.mockImplementation((data) => data as ItsmChangeTask);
      taskRepo.save.mockImplementation(async (e) => e as ItsmChangeTask);

      await service.createTask(TENANT, USER, CHANGE_ID, { title: 'Task 6' });

      expect(taskRepo.create).toHaveBeenCalledWith(
        expect.objectContaining({ number: 'CTASK00006' }),
      );
    });
  });

  // ──────────────────────────────────────────────────────────────────
  // UPDATE TASK
  // ──────────────────────────────────────────────────────────────────
  describe('updateTask', () => {
    it('should update task core fields', async () => {
      const existing = makeTask();
      taskRepo.findOne.mockResolvedValue(existing);
      taskRepo.save.mockImplementation(async (e) => e as ItsmChangeTask);

      const result = await service.updateTask(TENANT, USER, CHANGE_ID, TASK_A, {
        title: 'Updated Title',
        description: 'Updated desc',
      });

      expect(result).toBeDefined();
      expect(result!.title).toBe('Updated Title');
      expect(result!.updatedBy).toBe(USER);
    });

    it('should return null when task not found', async () => {
      taskRepo.findOne.mockResolvedValue(null);

      const result = await service.updateTask(TENANT, USER, CHANGE_ID, 'non-existent', {
        title: 'X',
      });

      expect(result).toBeNull();
    });

    it('should auto-set actualStartAt when transitioning to IN_PROGRESS', async () => {
      const existing = makeTask({ status: ChangeTaskStatus.OPEN, actualStartAt: null });
      taskRepo.findOne.mockResolvedValue(existing);
      depRepo.find.mockResolvedValue([]); // no predecessors, so ready
      taskRepo.save.mockImplementation(async (e) => e as ItsmChangeTask);

      const result = await service.updateTask(TENANT, USER, CHANGE_ID, TASK_A, {
        status: ChangeTaskStatus.IN_PROGRESS,
      });

      expect(result).toBeDefined();
      expect(result!.actualStartAt).toBeInstanceOf(Date);
    });

    it('should auto-set actualEndAt when transitioning to COMPLETED', async () => {
      const existing = makeTask({ status: ChangeTaskStatus.IN_PROGRESS, actualEndAt: null });
      taskRepo.findOne.mockResolvedValue(existing);
      taskRepo.save.mockImplementation(async (e) => e as ItsmChangeTask);

      const result = await service.updateTask(TENANT, USER, CHANGE_ID, TASK_A, {
        status: ChangeTaskStatus.COMPLETED,
      });

      expect(result).toBeDefined();
      expect(result!.actualEndAt).toBeInstanceOf(Date);
    });

    it('should auto-set actualEndAt when transitioning to FAILED', async () => {
      const existing = makeTask({ status: ChangeTaskStatus.IN_PROGRESS, actualEndAt: null });
      taskRepo.findOne.mockResolvedValue(existing);
      taskRepo.save.mockImplementation(async (e) => e as ItsmChangeTask);

      const result = await service.updateTask(TENANT, USER, CHANGE_ID, TASK_A, {
        status: ChangeTaskStatus.FAILED,
      });

      expect(result!.actualEndAt).toBeInstanceOf(Date);
    });

    it('should not overwrite existing actualStartAt', async () => {
      const existingDate = new Date('2025-01-01');
      const existing = makeTask({ status: ChangeTaskStatus.OPEN, actualStartAt: existingDate });
      taskRepo.findOne.mockResolvedValue(existing);
      depRepo.find.mockResolvedValue([]);
      taskRepo.save.mockImplementation(async (e) => e as ItsmChangeTask);

      const result = await service.updateTask(TENANT, USER, CHANGE_ID, TASK_A, {
        status: ChangeTaskStatus.IN_PROGRESS,
      });

      expect(result!.actualStartAt).toEqual(existingDate);
    });
  });

  // ──────────────────────────────────────────────────────────────────
  // DELETE TASK
  // ──────────────────────────────────────────────────────────────────
  describe('softDeleteTask', () => {
    it('should soft delete task and remove its dependencies', async () => {
      const existing = makeTask();
      taskRepo.findOne.mockResolvedValue(existing);
      taskRepo.save.mockImplementation(async (e) => e as ItsmChangeTask);
      const mockQb = {
        delete: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue({ affected: 2 }),
      };
      depRepo.createQueryBuilder.mockReturnValue(mockQb as never);

      const result = await service.softDeleteTask(TENANT, USER, CHANGE_ID, TASK_A);

      expect(result).toBe(true);
      expect(mockQb.execute).toHaveBeenCalled();
    });

    it('should return false when task not found', async () => {
      taskRepo.findOne.mockResolvedValue(null);

      const result = await service.softDeleteTask(TENANT, USER, CHANGE_ID, 'non-existent');

      expect(result).toBe(false);
    });
  });

  // ──────────────────────────────────────────────────────────────────
  // STATUS TRANSITIONS
  // ──────────────────────────────────────────────────────────────────
  describe('assertValidStatusTransition', () => {
    const validCases: [ChangeTaskStatus, ChangeTaskStatus][] = [
      [ChangeTaskStatus.DRAFT, ChangeTaskStatus.OPEN],
      [ChangeTaskStatus.DRAFT, ChangeTaskStatus.CANCELLED],
      [ChangeTaskStatus.OPEN, ChangeTaskStatus.IN_PROGRESS],
      [ChangeTaskStatus.OPEN, ChangeTaskStatus.SKIPPED],
      [ChangeTaskStatus.OPEN, ChangeTaskStatus.CANCELLED],
      [ChangeTaskStatus.IN_PROGRESS, ChangeTaskStatus.COMPLETED],
      [ChangeTaskStatus.IN_PROGRESS, ChangeTaskStatus.FAILED],
      [ChangeTaskStatus.IN_PROGRESS, ChangeTaskStatus.PENDING],
      [ChangeTaskStatus.IN_PROGRESS, ChangeTaskStatus.CANCELLED],
      [ChangeTaskStatus.PENDING, ChangeTaskStatus.IN_PROGRESS],
      [ChangeTaskStatus.PENDING, ChangeTaskStatus.CANCELLED],
      [ChangeTaskStatus.FAILED, ChangeTaskStatus.OPEN],
      [ChangeTaskStatus.FAILED, ChangeTaskStatus.CANCELLED],
    ];

    it.each(validCases)(
      'should allow transition from %s to %s',
      (from, to) => {
        expect(() => service.assertValidStatusTransition(from, to)).not.toThrow();
      },
    );

    const invalidCases: [ChangeTaskStatus, ChangeTaskStatus][] = [
      [ChangeTaskStatus.COMPLETED, ChangeTaskStatus.OPEN],
      [ChangeTaskStatus.COMPLETED, ChangeTaskStatus.IN_PROGRESS],
      [ChangeTaskStatus.SKIPPED, ChangeTaskStatus.OPEN],
      [ChangeTaskStatus.CANCELLED, ChangeTaskStatus.OPEN],
      [ChangeTaskStatus.DRAFT, ChangeTaskStatus.COMPLETED],
      [ChangeTaskStatus.DRAFT, ChangeTaskStatus.IN_PROGRESS],
      [ChangeTaskStatus.OPEN, ChangeTaskStatus.COMPLETED],
      [ChangeTaskStatus.OPEN, ChangeTaskStatus.FAILED],
    ];

    it.each(invalidCases)(
      'should reject transition from %s to %s',
      (from, to) => {
        expect(() => service.assertValidStatusTransition(from, to)).toThrow(
          BadRequestException,
        );
      },
    );
  });

  // ──────────────────────────────────────────────────────────────────
  // READINESS CALCULATION
  // ──────────────────────────────────────────────────────────────────
  describe('calculateReadiness', () => {
    it('should return ready when task has no predecessors', async () => {
      depRepo.find.mockResolvedValue([]);

      const result = await service.calculateReadiness(TENANT, CHANGE_ID, TASK_A);

      expect(result.isReady).toBe(true);
      expect(result.totalPredecessors).toBe(0);
      expect(result.blockingPredecessors).toEqual([]);
    });

    it('should return not ready when predecessor is incomplete', async () => {
      depRepo.find.mockResolvedValue([makeDep(TASK_B, TASK_A)]);
      const predTask = makeTask({ id: TASK_B, status: ChangeTaskStatus.IN_PROGRESS });
      taskRepo.createQueryBuilder = jest.fn().mockReturnValue({
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        getMany: jest.fn().mockResolvedValue([predTask]),
      });

      const result = await service.calculateReadiness(TENANT, CHANGE_ID, TASK_A);

      expect(result.isReady).toBe(false);
      expect(result.blockingPredecessors).toContain(TASK_B);
    });

    it('should return ready when predecessor is COMPLETED', async () => {
      depRepo.find.mockResolvedValue([makeDep(TASK_B, TASK_A)]);
      const predTask = makeTask({ id: TASK_B, status: ChangeTaskStatus.COMPLETED });
      taskRepo.createQueryBuilder = jest.fn().mockReturnValue({
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        getMany: jest.fn().mockResolvedValue([predTask]),
      });

      const result = await service.calculateReadiness(TENANT, CHANGE_ID, TASK_A);

      expect(result.isReady).toBe(true);
      expect(result.completedPredecessors).toContain(TASK_B);
    });

    it('should return ready when predecessor is SKIPPED', async () => {
      depRepo.find.mockResolvedValue([makeDep(TASK_B, TASK_A)]);
      const predTask = makeTask({ id: TASK_B, status: ChangeTaskStatus.SKIPPED });
      taskRepo.createQueryBuilder = jest.fn().mockReturnValue({
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        getMany: jest.fn().mockResolvedValue([predTask]),
      });

      const result = await service.calculateReadiness(TENANT, CHANGE_ID, TASK_A);

      expect(result.isReady).toBe(true);
    });

    it('should require ALL predecessors completed for multi-predecessor readiness', async () => {
      depRepo.find.mockResolvedValue([
        makeDep(TASK_B, TASK_A),
        makeDep(TASK_C, TASK_A),
      ]);
      const predB = makeTask({ id: TASK_B, status: ChangeTaskStatus.COMPLETED });
      const predC = makeTask({ id: TASK_C, status: ChangeTaskStatus.IN_PROGRESS });
      taskRepo.createQueryBuilder = jest.fn().mockReturnValue({
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        getMany: jest.fn().mockResolvedValue([predB, predC]),
      });

      const result = await service.calculateReadiness(TENANT, CHANGE_ID, TASK_A);

      expect(result.isReady).toBe(false);
      expect(result.blockingPredecessors).toContain(TASK_C);
      expect(result.completedPredecessors).toContain(TASK_B);
      expect(result.totalPredecessors).toBe(2);
    });

    it('should be ready when ALL multiple predecessors are completed', async () => {
      depRepo.find.mockResolvedValue([
        makeDep(TASK_B, TASK_A),
        makeDep(TASK_C, TASK_A),
      ]);
      const predB = makeTask({ id: TASK_B, status: ChangeTaskStatus.COMPLETED });
      const predC = makeTask({ id: TASK_C, status: ChangeTaskStatus.SKIPPED });
      taskRepo.createQueryBuilder = jest.fn().mockReturnValue({
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        getMany: jest.fn().mockResolvedValue([predB, predC]),
      });

      const result = await service.calculateReadiness(TENANT, CHANGE_ID, TASK_A);

      expect(result.isReady).toBe(true);
    });
  });

  // ──────────────────────────────────────────────────────────────────
  // READINESS CALCULATION — BATCH (calculateAllReadiness)
  // ──────────────────────────────────────────────────────────────────
  describe('calculateAllReadiness', () => {
    it('should calculate readiness for all tasks in a change', async () => {
      const taskA = makeTask({ id: TASK_A, status: ChangeTaskStatus.COMPLETED });
      const taskB = makeTask({ id: TASK_B, status: ChangeTaskStatus.OPEN });
      const taskC = makeTask({ id: TASK_C, status: ChangeTaskStatus.OPEN });

      taskRepo.find.mockResolvedValue([taskA, taskB, taskC]);
      depRepo.find.mockResolvedValue([
        makeDep(TASK_A, TASK_B), // A -> B
        makeDep(TASK_B, TASK_C), // B -> C
      ]);

      const result = await service.calculateAllReadiness(TENANT, CHANGE_ID);

      expect(result.get(TASK_A)!.isReady).toBe(true); // no predecessors
      expect(result.get(TASK_B)!.isReady).toBe(true); // A is completed
      expect(result.get(TASK_C)!.isReady).toBe(false); // B is not completed
    });
  });

  // ──────────────────────────────────────────────────────────────────
  // DEPENDENCY VALIDATION
  // ──────────────────────────────────────────────────────────────────
  describe('validateDependency', () => {
    it('should reject self-dependency', async () => {
      await expect(
        service.validateDependency(TENANT, CHANGE_ID, TASK_A, TASK_A),
      ).rejects.toThrow(BadRequestException);
    });

    it('should reject when predecessor task not found in change', async () => {
      taskRepo.findOne.mockResolvedValue(null);

      await expect(
        service.validateDependency(TENANT, CHANGE_ID, 'nonexistent', TASK_B),
      ).rejects.toThrow(NotFoundException);
    });

    it('should reject duplicate dependency', async () => {
      taskRepo.findOne.mockResolvedValue(makeTask());
      depRepo.findOne.mockResolvedValue(makeDep(TASK_A, TASK_B)); // already exists

      await expect(
        service.validateDependency(TENANT, CHANGE_ID, TASK_A, TASK_B),
      ).rejects.toThrow(ConflictException);
    });

    it('should reject cycle (A->B already exists, adding B->A)', async () => {
      // Both tasks exist
      taskRepo.findOne.mockResolvedValue(makeTask());
      // No duplicate
      depRepo.findOne.mockResolvedValueOnce(null);
      // Cycle detection: walking from B backwards, find B->A edge
      depRepo.find
        .mockResolvedValueOnce([makeDep(TASK_A, TASK_B)]) // predecessors of B: A->B means B has predecessor A
        .mockResolvedValueOnce([]); // predecessors of A: none

      // Actually: wouldCreateCycle checks if predecessor (B) can reach successor (A)
      // Adding B->A: walk backwards from B. B's predecessors include A? We need to mock successorTaskId = B
      // The actual query is: find where successorTaskId = current
      // Stack starts with B (predecessorId). First iteration checks current=B vs successorId=A? No.
      // Find deps where successorTaskId=B => those are predecessors of B
      // If A->B exists, then dep with predecessorTaskId=A, successorTaskId=B exists
      // So from B, we find A. Then from A, we check if A === A (successorId). Yes! Cycle detected.

      const result = await service.wouldCreateCycle(TENANT, CHANGE_ID, TASK_B, TASK_A);

      // Let's test this properly
      depRepo.find.mockReset();
      depRepo.find
        .mockResolvedValueOnce([makeDep(TASK_A, TASK_B)]) // predecessors of TASK_B (current = TASK_B, successorTaskId = TASK_B)
        .mockResolvedValueOnce([]); // predecessors of TASK_A

      const cycleResult = await service.wouldCreateCycle(TENANT, CHANGE_ID, TASK_B, TASK_A);
      expect(cycleResult).toBe(true);
    });

    it('should NOT detect cycle when no cycle exists', async () => {
      depRepo.find.mockResolvedValue([]); // no existing edges

      const result = await service.wouldCreateCycle(TENANT, CHANGE_ID, TASK_A, TASK_B);
      expect(result).toBe(false);
    });
  });

  // ──────────────────────────────────────────────────────────────────
  // DEPENDENCY CRUD
  // ──────────────────────────────────────────────────────────────────
  describe('addDependency', () => {
    it('should create a valid dependency', async () => {
      // validateDependency mocks
      taskRepo.findOne.mockResolvedValue(makeTask());
      depRepo.findOne.mockResolvedValue(null); // no duplicate
      depRepo.find.mockResolvedValue([]); // no cycle
      depRepo.create.mockImplementation((d) => d as ItsmChangeTaskDependency);
      depRepo.save.mockImplementation(async (d) => ({ ...d, id: 'dep-1' }) as ItsmChangeTaskDependency);

      const result = await service.addDependency(TENANT, CHANGE_ID, TASK_A, TASK_B);

      expect(result).toBeDefined();
      expect(depRepo.create).toHaveBeenCalledWith(
        expect.objectContaining({
          tenantId: TENANT,
          changeId: CHANGE_ID,
          predecessorTaskId: TASK_A,
          successorTaskId: TASK_B,
        }),
      );
    });
  });

  describe('removeDependency', () => {
    it('should remove existing dependency', async () => {
      const dep = makeDep(TASK_A, TASK_B);
      depRepo.findOne.mockResolvedValue(dep);
      depRepo.remove.mockResolvedValue(dep);

      const result = await service.removeDependency(TENANT, CHANGE_ID, TASK_A, TASK_B);

      expect(result).toBe(true);
      expect(depRepo.remove).toHaveBeenCalledWith(dep);
    });

    it('should return false when dependency not found', async () => {
      depRepo.findOne.mockResolvedValue(null);

      const result = await service.removeDependency(TENANT, CHANGE_ID, TASK_A, TASK_B);

      expect(result).toBe(false);
    });
  });

  describe('getDependencies', () => {
    it('should return all dependencies for a change', async () => {
      const deps = [makeDep(TASK_A, TASK_B), makeDep(TASK_B, TASK_C)];
      depRepo.find.mockResolvedValue(deps);

      const result = await service.getDependencies(TENANT, CHANGE_ID);

      expect(result).toHaveLength(2);
      expect(depRepo.find).toHaveBeenCalledWith({
        where: { tenantId: TENANT, changeId: CHANGE_ID },
      });
    });
  });

  // ──────────────────────────────────────────────────────────────────
  // BLOCKED TASK STATUS TRANSITION
  // ──────────────────────────────────────────────────────────────────
  describe('blocked task cannot start', () => {
    it('should reject IN_PROGRESS transition when predecessors are not completed', async () => {
      const existing = makeTask({ status: ChangeTaskStatus.OPEN });
      taskRepo.findOne.mockResolvedValue(existing);
      // calculateReadiness: has blocking predecessor
      depRepo.find.mockResolvedValue([makeDep(TASK_B, TASK_A)]);
      const predTask = makeTask({ id: TASK_B, status: ChangeTaskStatus.IN_PROGRESS });
      taskRepo.createQueryBuilder = jest.fn().mockReturnValue({
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        getMany: jest.fn().mockResolvedValue([predTask]),
      });

      await expect(
        service.updateTask(TENANT, USER, CHANGE_ID, TASK_A, {
          status: ChangeTaskStatus.IN_PROGRESS,
        }),
      ).rejects.toThrow(ConflictException);
    });
  });

  // ──────────────────────────────────────────────────────────────────
  // SUMMARY / PROGRESS
  // ──────────────────────────────────────────────────────────────────
  describe('getTaskSummary', () => {
    it('should return correct counts by status', async () => {
      const tasks = [
        makeTask({ id: 't1', status: ChangeTaskStatus.COMPLETED }),
        makeTask({ id: 't2', status: ChangeTaskStatus.COMPLETED }),
        makeTask({ id: 't3', status: ChangeTaskStatus.IN_PROGRESS }),
        makeTask({ id: 't4', status: ChangeTaskStatus.OPEN }),
        makeTask({ id: 't5', status: ChangeTaskStatus.DRAFT }),
      ];
      taskRepo.find.mockResolvedValue(tasks);
      depRepo.find.mockResolvedValue([]); // no deps — all ready

      const summary = await service.getTaskSummary(TENANT, CHANGE_ID);

      expect(summary.total).toBe(5);
      expect(summary.completed).toBe(2);
      expect(summary.inProgress).toBe(1);
      expect(summary.open).toBe(1);
      expect(summary.draft).toBe(1);
      expect(summary.failed).toBe(0);
      expect(summary.skipped).toBe(0);
      expect(summary.cancelled).toBe(0);
    });

    it('should calculate ready and blocked counts', async () => {
      const tasks = [
        makeTask({ id: TASK_A, status: ChangeTaskStatus.COMPLETED }),
        makeTask({ id: TASK_B, status: ChangeTaskStatus.OPEN }),
        makeTask({ id: TASK_C, status: ChangeTaskStatus.OPEN }),
      ];
      taskRepo.find.mockResolvedValue(tasks);
      depRepo.find.mockResolvedValue([
        makeDep(TASK_A, TASK_B), // A -> B
        makeDep(TASK_B, TASK_C), // B -> C
      ]);

      const summary = await service.getTaskSummary(TENANT, CHANGE_ID);

      // A is completed (terminal), B is ready (A completed), C is blocked (B not completed)
      expect(summary.ready).toBe(1); // B
      expect(summary.blocked).toBe(1); // C
    });

    it('should return zero counts for empty task list', async () => {
      taskRepo.find.mockResolvedValue([]);
      depRepo.find.mockResolvedValue([]);

      const summary = await service.getTaskSummary(TENANT, CHANGE_ID);

      expect(summary.total).toBe(0);
      expect(summary.ready).toBe(0);
      expect(summary.blocked).toBe(0);
    });
  });

  // ──────────────────────────────────────────────────────────────────
  // FIND TASKS WITH ORDERING
  // ──────────────────────────────────────────────────────────────────
  describe('findTasksForChange', () => {
    it('should return paginated tasks with readiness data', async () => {
      const tasks = [makeTask({ id: TASK_A }), makeTask({ id: TASK_B })];
      const mockQb = {
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        orderBy: jest.fn().mockReturnThis(),
        addOrderBy: jest.fn().mockReturnThis(),
        skip: jest.fn().mockReturnThis(),
        take: jest.fn().mockReturnThis(),
        getCount: jest.fn().mockResolvedValue(2),
        getMany: jest.fn().mockResolvedValue(tasks),
      };
      taskRepo.createQueryBuilder.mockReturnValue(mockQb as never);
      // calculateAllReadiness mocks
      taskRepo.find.mockResolvedValue(tasks);
      depRepo.find.mockResolvedValue([]);

      const result = await service.findTasksForChange(TENANT, CHANGE_ID, {
        page: 1,
        pageSize: 50,
      } as never);

      expect(result.items).toHaveLength(2);
      expect(result.total).toBe(2);
      expect(result.page).toBe(1);
      expect(result.items[0]).toHaveProperty('readiness');
      expect(result.items[0].readiness!.isReady).toBe(true);
    });
  });
});
