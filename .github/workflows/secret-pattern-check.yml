# =============================================================================
# GRC Platform - Secret Pattern Check Workflow
# =============================================================================
# Scans tracked files for strings that resemble real secrets (high entropy,
# API key patterns, JWT-like tokens, etc.). Uses an allowlist for known safe
# patterns like test fixtures and documentation examples.
#
# Risk Level: P1 (High) - Prevents accidental secret commits
#
# This complements:
# - secret-scanning.yml (TruffleHog for verified secrets)
# - credential-check.yml (known credential patterns)
# =============================================================================

name: Secret Pattern Check

on:
  push:
    branches:
      - main
      - 'devin/**'
  pull_request:
    branches:
      - main

jobs:
  secret-pattern-check:
    name: Check for Secret-like Patterns
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Scan for secret-like patterns
        run: |
          echo "Scanning for secret-like patterns in tracked files..."
          
          # Load allowlist patterns
          ALLOWLIST_FILE=".github/secret-allowlist.txt"
          declare -a ALLOWLIST=()
          
          if [ -f "$ALLOWLIST_FILE" ]; then
            while IFS= read -r line || [ -n "$line" ]; do
              # Skip comments and empty lines
              [[ "$line" =~ ^#.*$ ]] && continue
              [[ -z "$line" ]] && continue
              ALLOWLIST+=("$line")
            done < "$ALLOWLIST_FILE"
            echo "Loaded ${#ALLOWLIST[@]} allowlist patterns"
          else
            echo "Warning: Allowlist file not found at $ALLOWLIST_FILE"
          fi
          
          # Function to check if a string is in the allowlist
          is_allowlisted() {
            local str="$1"
            for pattern in "${ALLOWLIST[@]}"; do
              if [[ "$str" == *"$pattern"* ]]; then
                return 0
              fi
            done
            return 1
          }
          
          # Directories and files to exclude
          EXCLUDE_PATTERNS=(
            "node_modules"
            "dist"
            "build"
            "coverage"
            ".git"
            "*.lock"
            "package-lock.json"
            "*.min.js"
            "*.min.css"
            "*.map"
            "playwright-report"
            "test-results"
          )
          
          # Build find exclude arguments
          FIND_EXCLUDES=""
          for pattern in "${EXCLUDE_PATTERNS[@]}"; do
            FIND_EXCLUDES="$FIND_EXCLUDES -path '*/$pattern' -prune -o -path '*/$pattern/*' -prune -o"
          done
          
          FOUND_ISSUES=0
          
          # Pattern 1: JWT-like tokens (three base64 segments)
          # Matches: eyJ...header.eyJ...payload.signature
          echo "Checking for JWT-like tokens..."
          JWT_PATTERN='eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}'
          
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            while IFS=: read -r line_num match; do
              if ! is_allowlisted "$match"; then
                echo "WARNING: Possible JWT token in $file:$line_num"
                echo "  Match: ${match:0:50}..."
                FOUND_ISSUES=1
              fi
            done < <(grep -noE "$JWT_PATTERN" "$file" 2>/dev/null || true)
          done < <(eval "find . $FIND_EXCLUDES -type f \( -name '*.ts' -o -name '*.tsx' -o -name '*.js' -o -name '*.jsx' -o -name '*.json' -o -name '*.yml' -o -name '*.yaml' -o -name '*.env*' \) -print" 2>/dev/null)
          
          # Pattern 2: API key patterns (common formats)
          # Matches: sk_live_xxx, pk_test_xxx, AKIA..., etc.
          echo "Checking for API key patterns..."
          API_KEY_PATTERNS=(
            'sk_live_[A-Za-z0-9]{20,}'
            'pk_live_[A-Za-z0-9]{20,}'
            'sk_test_[A-Za-z0-9]{20,}'
            'pk_test_[A-Za-z0-9]{20,}'
            'AKIA[A-Z0-9]{16}'
            'ghp_[A-Za-z0-9]{36}'
            'gho_[A-Za-z0-9]{36}'
            'github_pat_[A-Za-z0-9_]{22,}'
          )
          
          for pattern in "${API_KEY_PATTERNS[@]}"; do
            while IFS= read -r file; do
              [ -z "$file" ] && continue
              while IFS=: read -r line_num match; do
                if ! is_allowlisted "$match"; then
                  echo "WARNING: Possible API key in $file:$line_num"
                  echo "  Pattern: $pattern"
                  echo "  Match: ${match:0:30}..."
                  FOUND_ISSUES=1
                fi
              done < <(grep -noE "$pattern" "$file" 2>/dev/null || true)
            done < <(eval "find . $FIND_EXCLUDES -type f \( -name '*.ts' -o -name '*.tsx' -o -name '*.js' -o -name '*.jsx' -o -name '*.json' -o -name '*.yml' -o -name '*.yaml' -o -name '*.env*' \) -print" 2>/dev/null)
          done
          
          # Pattern 3: Private key headers
          echo "Checking for private key headers..."
          PRIVATE_KEY_PATTERN='-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----'
          
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            if grep -qE "$PRIVATE_KEY_PATTERN" "$file" 2>/dev/null; then
              echo "ERROR: Private key found in $file"
              FOUND_ISSUES=1
            fi
          done < <(eval "find . $FIND_EXCLUDES -type f -print" 2>/dev/null)
          
          # Summary
          echo ""
          if [ $FOUND_ISSUES -eq 1 ]; then
            echo "FAILURE: Secret-like patterns found in tracked files."
            echo "If these are intentional (test fixtures, examples), add them to .github/secret-allowlist.txt"
            exit 1
          fi
          
          echo "SUCCESS: No secret-like patterns found in tracked files."
