# =============================================================================
# GRC Platform - Staging Deployment Workflow
# =============================================================================
# Deploys to Hetzner staging server (46.224.99.150)
#
# Triggers:
#   - Manual workflow dispatch
#   - Push to main branch (optional, can be enabled)
#
# Secrets Required:
#   - STAGING_SSH_HOST: 46.224.99.150
#   - STAGING_SSH_USER: root (or grcdeploy)
#   - STAGING_SSH_KEY: Private SSH key (BEGIN/END OPENSSH format)
#
# Deployment Path: /opt/grc-platform
# =============================================================================

name: Deploy to Staging

on:
  workflow_dispatch:
  # Uncomment to auto-deploy on push to main:
  # push:
  #   branches:
  #     - main

env:
  DEPLOY_PATH: /opt/grc-platform
  STAGING_HOST: ${{ secrets.STAGING_SSH_HOST }}
  STAGING_USER: ${{ secrets.STAGING_SSH_USER }}

jobs:
  deploy:
    name: Deploy to Staging Server
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
      
      - name: Deploy to staging server
        uses: appleboy/ssh-action@v1.2.4
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            set -euo pipefail
            
            echo "=== Starting Staging Deployment ==="
            echo "Deploy path: ${{ env.DEPLOY_PATH }}"
            echo "Timestamp: $(date)"
            
            # Navigate to deploy path
            cd ${{ env.DEPLOY_PATH }} || {
              echo "ERROR: Deploy path ${{ env.DEPLOY_PATH }} does not exist!"
              exit 1
            }
            
            # Check git status
            echo "=== Git Status ==="
            git status
            
            # Fetch latest changes
            echo "=== Fetching latest changes ==="
            git fetch --all
            
            # Checkout main branch
            echo "=== Checking out main branch ==="
            git checkout main || {
              echo "ERROR: Failed to checkout main branch"
              exit 1
            }
            
            # Pull latest changes
            echo "=== Pulling latest changes ==="
            git pull origin main || {
              echo "ERROR: Failed to pull latest changes"
              exit 1
            }
            
            # Show current commit
            echo "=== Current Commit ==="
            git log -1 --oneline
            
            # Check Docker and Docker Compose
            echo "=== Docker Environment ==="
            docker --version
            docker compose version || docker-compose --version
            
            # Deploy with Docker Compose
            echo "=== Deploying with Docker Compose ==="
            docker compose -f docker-compose.staging.yml up -d --build --force-recreate || {
              echo "ERROR: Docker Compose deployment failed"
              docker compose -f docker-compose.staging.yml logs
              exit 1
            }
            
            # Wait for services to be healthy
            echo "=== Waiting for services to be healthy ==="
            sleep 10
            
            # Check container status
            echo "=== Container Status ==="
            docker compose -f docker-compose.staging.yml ps
            
            # Health checks
            echo "=== Health Checks ==="
            
            # Backend health check
            echo "Checking backend health..."
            for i in {1..30}; do
              if curl -sf http://localhost:3002/health/live > /dev/null; then
                echo "✓ Backend health check passed"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "✗ Backend health check failed after 30 attempts"
                docker compose -f docker-compose.staging.yml logs backend
                exit 1
              fi
              echo "Waiting for backend... ($i/30)"
              sleep 2
            done
            
            # Frontend health check
            echo "Checking frontend health..."
            for i in {1..30}; do
              if curl -sf http://localhost/health > /dev/null; then
                echo "✓ Frontend health check passed"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "✗ Frontend health check failed after 30 attempts"
                docker compose -f docker-compose.staging.yml logs frontend
                exit 1
              fi
              echo "Waiting for frontend... ($i/30)"
              sleep 2
            done
            
            # =============================================================================
            # Security Smoke Tests - Tenant Isolation Verification
            # =============================================================================
            echo "=== Security Smoke Tests ==="
            
            # Track test status for final summary
            SECURITY_TESTS_STATUS="SKIPPED"
            SECURITY_TESTS_REASON=""
            
            # Check if jq is available (required for reliable JSON parsing)
            if ! command -v jq &> /dev/null; then
              echo "WARNING: jq is not installed, skipping security smoke tests"
              echo "  (GitHub Actions ubuntu runners should have jq pre-installed)"
              SECURITY_TESTS_REASON="jq not available"
            else
              # Get auth token for security tests
              # Uses DEMO_ADMIN_EMAIL and DEMO_ADMIN_PASSWORD from staging .env
              echo "Authenticating for security tests..."
              DEMO_EMAIL="${DEMO_ADMIN_EMAIL:-admin@demo.local}"
              DEMO_PASS="${DEMO_ADMIN_PASSWORD:-}"
              
              if [ -z "$DEMO_PASS" ]; then
                echo "WARNING: DEMO_ADMIN_PASSWORD not set, skipping security smoke tests"
                SECURITY_TESTS_REASON="DEMO_ADMIN_PASSWORD not set"
              else
                AUTH_RESPONSE=$(curl -sf -X POST http://localhost:3002/auth/login \
                  -H "Content-Type: application/json" \
                  -d "{\"email\":\"$DEMO_EMAIL\",\"password\":\"$DEMO_PASS\"}" 2>/dev/null) || {
                  echo "WARNING: Could not authenticate for security tests (demo admin may not exist)"
                  SECURITY_TESTS_REASON="authentication failed"
                  AUTH_RESPONSE=""
                }
                
                if [ -n "$AUTH_RESPONSE" ]; then
                  # Parse token and tenant ID using jq (handles both envelope and non-envelope responses)
                  # Envelope format: {"success": true, "data": {"accessToken": "...", "tenantId": "..."}}
                  # Non-envelope format: {"accessToken": "...", "tenantId": "..."}
                  TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.data.accessToken // .accessToken // empty' 2>/dev/null)
                  TENANT_ID=$(echo "$AUTH_RESPONSE" | jq -r '.data.tenantId // .tenantId // empty' 2>/dev/null)
                  
                  if [ -z "$TOKEN" ] || [ -z "$TENANT_ID" ]; then
                    echo "WARNING: Could not extract token or tenant ID from auth response"
                    # Print safe redacted snippet for debugging (no secrets)
                    echo "  Response structure (redacted): $(echo "$AUTH_RESPONSE" | jq -r 'keys | join(", ")' 2>/dev/null || echo 'invalid JSON')"
                    if echo "$AUTH_RESPONSE" | jq -e '.data' &>/dev/null; then
                      echo "  Data keys: $(echo "$AUTH_RESPONSE" | jq -r '.data | keys | join(", ")' 2>/dev/null || echo 'none')"
                    fi
                    SECURITY_TESTS_REASON="token/tenant extraction failed"
                  else
                    SECURITY_TESTS_STATUS="RUNNING"
                    echo "Authentication successful. Running security tests..."
                    
                    # Test 1: Missing x-tenant-id header should return 400
                    echo "Test 1: /platform/modules/menu/nested without x-tenant-id..."
                    HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
                      -H "Authorization: Bearer $TOKEN" \
                      http://localhost:3002/platform/modules/menu/nested)
                    if [ "$HTTP_CODE" = "400" ]; then
                      echo "  PASS: Missing tenant header returns 400"
                    else
                      echo "  FAIL: Expected 400, got $HTTP_CODE"
                      docker compose -f docker-compose.staging.yml logs backend db
                      exit 1
                    fi
                    
                    # Test 2: Spoof tenant ID should return 403
                    echo "Test 2: /platform/modules/menu/nested with spoof tenant ID..."
                    SPOOF_TENANT="00000000-0000-0000-0000-000000000099"
                    HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
                      -H "Authorization: Bearer $TOKEN" \
                      -H "x-tenant-id: $SPOOF_TENANT" \
                      http://localhost:3002/platform/modules/menu/nested)
                    if [ "$HTTP_CODE" = "403" ]; then
                      echo "  PASS: Spoof tenant ID returns 403"
                    else
                      echo "  FAIL: Expected 403, got $HTTP_CODE"
                      docker compose -f docker-compose.staging.yml logs backend db
                      exit 1
                    fi
                    
                    # Test 3: /onboarding/context with correct headers should return 200
                    echo "Test 3: /onboarding/context with valid headers..."
                    HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
                      -H "Authorization: Bearer $TOKEN" \
                      -H "x-tenant-id: $TENANT_ID" \
                      http://localhost:3002/onboarding/context)
                    if [ "$HTTP_CODE" = "200" ]; then
                      echo "  PASS: Valid request returns 200"
                    else
                      echo "  FAIL: Expected 200, got $HTTP_CODE"
                      docker compose -f docker-compose.staging.yml logs backend db
                      exit 1
                    fi
                    
                    echo "All security smoke tests passed!"
                  fi
                fi
              fi
            fi
            
            # Final status summary for workflow output
            echo ""
            echo "=== Security Smoke Tests Status ==="
            if [ "$SECURITY_TESTS_STATUS" = "RUNNING" ]; then
              echo "SECURITY_SMOKE_TESTS: RUNNING - All tests executed and passed"
            else
              echo "SECURITY_SMOKE_TESTS: SKIPPED - Reason: ${SECURITY_TESTS_REASON:-unknown}"
            fi
            
            echo "=== Deployment Complete ==="
            echo "Frontend: http://${{ secrets.STAGING_SSH_HOST }}"
            echo "Backend API: http://${{ secrets.STAGING_SSH_HOST }}:3002"
            echo "Backend Health: http://${{ secrets.STAGING_SSH_HOST }}:3002/health/live"

